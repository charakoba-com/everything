package repository

// Code generated by genentity.go. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"github.com/charakoba-com/everything/faultinfo/db"
	"github.com/charakoba-com/everything/faultinfo/domain/model"
)

type InformationRepository struct {
	DB *sql.DB
}

func NewInformationRepository() (*InformationRepository, error) {
	_db, err := db.Get()
	if err != nil {
		return nil, err
	}
	return &InformationRepository{
		DB: _db,
	}, nil
}

func (r *InformationRepository) Create(ctx context.Context, v model.Information) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	stmt, err := tx.Prepare("INSERT INTO information (id, detail, updated_at, updater, creator, type, begin, end, template_id, created_at) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")
	if err != nil {
		return err
	}
	if _, err := stmt.Exec(v.ID, v.Detail, v.UpdatedAt, v.Updater, v.Creator, v.Type, v.Begin, v.End, v.TemplateID, v.CreatedAt); err != nil {
		return err
	}
	return tx.Commit()
}

func (r *InformationRepository) Listup(ctx context.Context) ([]model.Information, error) {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	stmt, err := tx.Prepare("SELECT id, detail, updated_at, updater, creator, type, begin, end, template_id, created_at FROM information")
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query()
	if err != nil {
		return nil, err
	}
	var vs []model.Information
	for rows.Next() {
		var v model.Information
		if err := rows.Scan(&v.ID, &v.Detail, &v.UpdatedAt, &v.Updater, &v.Creator, &v.Type, &v.Begin, &v.End, &v.TemplateID, &v.CreatedAt); err != nil {
			return nil, err
		}
	}
	return vs, nil
}

func (r *InformationRepository) FindByPK(ctx context.Context, pk interface{}) (*model.Information, error) {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	stmt, err := tx.Prepare("SELECT id, detail, updated_at, updater, creator, type, begin, end, template_id, created_at FROM information WHERE id = ?")
	if err != nil {
		return nil, err
	}
	row := stmt.QueryRow(pk)
	var v *model.Information
	if err := row.Scan(&v.ID, &v.Detail, &v.UpdatedAt, &v.Updater, &v.Creator, &v.Type, &v.Begin, &v.End, &v.TemplateID, &v.CreatedAt); err != nil {
		return nil, err
	}
	return v, nil
}

func (r *InformationRepository) Update(ctx context.Context, v model.Information) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	stmt, err := tx.Prepare("UPDATE information SET (id=?, detail=?, updated_at=?, updater=?, creator=?, type=?, begin=?, end=?, template_id=?, created_at=?) WHERE id=?")
	if err != nil {
		return err
	}
	if _, err := stmt.Exec(v.ID, v.Detail, v.UpdatedAt, v.Updater, v.Creator, v.Type, v.Begin, v.End, v.TemplateID, v.CreatedAt, v.ID); err != nil {
		return err
	}
	return tx.Commit()
}

func (r *InformationRepository) Delete(ctx context.Context, v model.Information) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	stmt, err := tx.Prepare("DELETE FROM information WHERE id = ?")
	if err != nil {
		return err
	}
	if _, err := stmt.Exec(v.ID); err != nil {
		return err
	}
	return tx.Commit()
}

type CommentRepository struct {
	DB *sql.DB
}

func NewCommentRepository() (*CommentRepository, error) {
	_db, err := db.Get()
	if err != nil {
		return nil, err
	}
	return &CommentRepository{
		DB: _db,
	}, nil
}

func (r *CommentRepository) Create(ctx context.Context, v model.Comment) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	stmt, err := tx.Prepare("INSERT INTO comment (id, information_id, creator, body, created_at) VALUES(?, ?, ?, ?, ?)")
	if err != nil {
		return err
	}
	if _, err := stmt.Exec(v.ID, v.InformationID, v.Creator, v.Body, v.CreatedAt); err != nil {
		return err
	}
	return tx.Commit()
}

func (r *CommentRepository) Listup(ctx context.Context) ([]model.Comment, error) {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	stmt, err := tx.Prepare("SELECT id, information_id, creator, body, created_at FROM comment")
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query()
	if err != nil {
		return nil, err
	}
	var vs []model.Comment
	for rows.Next() {
		var v model.Comment
		if err := rows.Scan(&v.ID, &v.InformationID, &v.Creator, &v.Body, &v.CreatedAt); err != nil {
			return nil, err
		}
	}
	return vs, nil
}

func (r *CommentRepository) FindByPK(ctx context.Context, pk interface{}) (*model.Comment, error) {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	stmt, err := tx.Prepare("SELECT id, information_id, creator, body, created_at FROM comment WHERE id = ?")
	if err != nil {
		return nil, err
	}
	row := stmt.QueryRow(pk)
	var v *model.Comment
	if err := row.Scan(&v.ID, &v.InformationID, &v.Creator, &v.Body, &v.CreatedAt); err != nil {
		return nil, err
	}
	return v, nil
}

func (r *CommentRepository) Update(ctx context.Context, v model.Comment) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	stmt, err := tx.Prepare("UPDATE comment SET (id=?, information_id=?, creator=?, body=?, created_at=?) WHERE id=?")
	if err != nil {
		return err
	}
	if _, err := stmt.Exec(v.ID, v.InformationID, v.Creator, v.Body, v.CreatedAt, v.ID); err != nil {
		return err
	}
	return tx.Commit()
}

func (r *CommentRepository) Delete(ctx context.Context, v model.Comment) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	stmt, err := tx.Prepare("DELETE FROM comment WHERE id = ?")
	if err != nil {
		return err
	}
	if _, err := stmt.Exec(v.ID); err != nil {
		return err
	}
	return tx.Commit()
}
