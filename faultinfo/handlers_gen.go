package faultinfo

// Code generated by genserver.go. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"

	"github.com/charakoba-com/everything/faultinfo/input"
)

const bearerType = "Bearer"

func Authenticate(token string) bool {
	return true
}

func GetCommentDetailHandler(w http.ResponseWriter, r *http.Request) {
	infoId := mux.Vars(r)["info_id"]
	commentId := mux.Vars(r)["comment_id"]
	out, err := GetCommentDetail(r.Context(), infoId, commentId)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func UpdateCommentHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	infoId := mux.Vars(r)["info_id"]
	commentId := mux.Vars(r)["comment_id"]
	var req input.CreateComment
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	err := UpdateComment(r.Context(), infoId, commentId, req)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func DeleteCommentHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	infoId := mux.Vars(r)["info_id"]
	commentId := mux.Vars(r)["comment_id"]
	err := DeleteComment(r.Context(), infoId, commentId)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func GetInformationTypelistHandler(w http.ResponseWriter, r *http.Request) {
	out, err := GetInformationTypelist(r.Context())
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func CreateInformationTypeHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	var req input.CreateInfoType
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	err := CreateInformationType(r.Context(), req)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func DeleteInformationTypeHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	typ := mux.Vars(r)["typ"]
	err := DeleteInformationType(r.Context(), typ)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func GetInformationTemplateIDListHandler(w http.ResponseWriter, r *http.Request) {
	out, err := GetInformationTemplateIDList(r.Context())
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func CreateInformationTemplateHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	var req input.CreateTemplate
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	err := CreateInformationTemplate(r.Context(), req)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func GetInformationTemplateDetailHandler(w http.ResponseWriter, r *http.Request) {
	id := mux.Vars(r)["id"]
	out, err := GetInformationTemplateDetail(r.Context(), id)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func DeleteInformationTemplateHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	id := mux.Vars(r)["id"]
	err := DeleteInformationTemplate(r.Context(), id)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func GetInformationListHandler(w http.ResponseWriter, r *http.Request) {
	out, err := GetInformationList(r.Context())
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func CreateInformationHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	var req input.CreateInformation
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	out, err := CreateInformation(r.Context(), req)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusCreated)
	buf.WriteTo(w)
}

func GetInformationDetailHandler(w http.ResponseWriter, r *http.Request) {
	id := mux.Vars(r)["id"]
	out, err := GetInformationDetail(r.Context(), id)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func UpdateInformationHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	id := mux.Vars(r)["id"]
	var req input.CreateInformation
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	err := UpdateInformation(r.Context(), id, req)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func DeleteInformationHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	id := mux.Vars(r)["id"]
	err := DeleteInformation(r.Context(), id)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func GetCommentListHandler(w http.ResponseWriter, r *http.Request) {
	id := mux.Vars(r)["id"]
	out, err := GetCommentList(r.Context(), id)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusOK)
	buf.WriteTo(w)
}

func CreateCommentHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := strings.Split(r.Header.Get("Authorization"), " ")
	if len(authHeader) != 2 || authHeader[0] != bearerType {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	bearerToken := authHeader[1]
	if !Authenticate(bearerToken) {
		w.Header().Set("WWW-Authenticate", "Bearer realm=\"ident\"")
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	id := mux.Vars(r)["id"]
	var req input.CreateComment
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	out, err := CreateComment(r.Context(), id, req)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(out); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusCreated)
	buf.WriteTo(w)
}
