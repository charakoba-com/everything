package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"unicode"

	flags "github.com/jessevdk/go-flags"
	openapi "github.com/nasa9084/go-openapi"
)

const (
	arrayType       = "array"
	objectType      = "object"
	stringType      = "string"
	applicationjson = "application/json"
)

type options struct {
	SpecFile string `short:"f" long:"file"`
}

func main() { os.Exit(exec()) }

func exec() int {
	var opts options
	if _, err := flags.Parse(&opts); err != nil {
		log.Print(err)
		return 1
	}
	doc, err := openapi.Load(opts.SpecFile)
	if err != nil {
		log.Print(err)
		return 1
	}
	if err := generate(doc); err != nil {
		log.Print(err)
		return 1
	}
	return 0
}

func writeTo(src []byte, filename string) error {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.Write(src)
	return err
}

func generate(doc *openapi.Document) error {
	if err := generateRoutes(doc.Paths); err != nil {
		return err
	}
	if err := generateRequestBodies(doc.Components.RequestBodies); err != nil {
		return err
	}
	if err := generateResponses(doc.Components.Responses); err != nil {
		return err
	}
	if err := generateSchemas(doc.Components.Schemas); err != nil {
		return err
	}
	if err := generateHandlers(doc.Paths); err != nil {
		return err
	}
	if _, err := os.Stat("logic_gen.go"); os.IsNotExist(err) {
		if err := generateLogics(doc.Paths); err != nil {
			return err
		}
	}
	return nil
}

func generateRoutes(paths openapi.Paths) error {
	var buf bytes.Buffer
	buf.WriteString(`package faultinfo
// Code generated genserver.go. DO NOT EDIT.

import (
"net/http"

"github.com/gorilla/mux"
)`)
	buf.WriteString("\n\nfunc bindroutes(router *mux.Router) {")
	for path, pathitem := range paths {
		if pathitem.Get != nil {
			generateRoute(&buf, path, pathitem.Get.OperationID, http.MethodGet)
		}
		if pathitem.Post != nil {
			generateRoute(&buf, path, pathitem.Post.OperationID, http.MethodPost)
		}
		if pathitem.Put != nil {
			generateRoute(&buf, path, pathitem.Put.OperationID, http.MethodPut)
		}
		if pathitem.Delete != nil {
			generateRoute(&buf, path, pathitem.Delete.OperationID, http.MethodDelete)
		}
	}
	buf.WriteString("\n}")
	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return writeTo(src, "routings_gen.go")
}

func generateRoute(buf *bytes.Buffer, path, opid, method string) {
	buf.WriteString(fmt.Sprintf(
		"\nrouter.HandlerFunc(%s, %s).Methods(http.Method%s)",
		strconv.Quote(path), opid, method,
	))
}

func generateRequestBodies(requestBodies map[string]*openapi.RequestBody) error {
	var buf bytes.Buffer
	buf.WriteString(`package faultinfo
// Code generated by genserver.go. DO NOT EDIT.
`)
	for name, requestBody := range requestBodies {
		if err := generateRequestBody(&buf, name, requestBody); err != nil {
			return err
		}
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return writeTo(src, "input/requestbody.go")
}

func generateRequestBody(buf *bytes.Buffer, name string, requestBody *openapi.RequestBody) error {
	buf.WriteString(fmt.Sprintf("\n\ntype %s ", name))
	switch requestBody.Content[applicationjson].Schema.Type {
	case objectType:
		buf.WriteString("struct {")
		for _, p := range requestBody.Content[applicationjson].Schema.Properties {
			if p.Type == objectType && p.EnableAdditionalProperties {
				buf.WriteString(fmt.Sprintf("\n%s map[string]string", p.Title))
				continue
			}
			buf.WriteString(fmt.Sprintf("\n%s %s", p.Title, p.Type))
		}
		buf.WriteString("\n}")
	default:
		buf.WriteString(requestBody.Content[applicationjson].Schema.Type)
	}
	return nil
}

func generateResponses(responses map[string]*openapi.Response) error {
	var buf bytes.Buffer
	buf.WriteString(`package output
// Code generated by genserver.go. DO NOT EDIT.
`)
	for name, response := range responses {
		if err := generateResponse(&buf, name, response); err != nil {
			return err
		}
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return writeTo(src, "output/response_gen.go")
}

func generateResponse(buf *bytes.Buffer, name string, response *openapi.Response) error {
	buf.WriteString(fmt.Sprintf("\n\ntype %s struct {", name))
	for n, p := range response.Content[applicationjson].Schema.Properties {
		buf.WriteString(fmt.Sprintf("\n%s %s `json:%s`", p.Title, p.Type, strconv.Quote(n)))
	}
	buf.WriteString("\n}")
	return nil
}

func generateSchemas(schemas map[string]*openapi.Schema) error {
	var buf bytes.Buffer
	buf.WriteString(`package schema
// Code generated by genserver.go. DO NOT EDIT.
`)
	for name, schema := range schemas {
		if err := generateSchema(&buf, name, schema); err != nil {
			return err
		}
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return writeTo(src, "schema/schema_gen.go")
}

func generateSchema(buf *bytes.Buffer, name string, schema *openapi.Schema) error {
	buf.WriteString(fmt.Sprintf("\n\ntype %s ", name))
	if schema.Type != objectType {
		buf.WriteString(schema.Type)
		return nil
	}
	buf.WriteString("struct {")
	for n, p := range schema.Properties {
		buf.WriteString("\n" + p.Title)
		switch p.Type {
		case stringType:
			var typ string
			switch p.Format {
			case "":
				typ = stringType
			case "date-time":
				typ = "time.Time"
			}
			buf.WriteString(fmt.Sprintf(" %s", typ))
		case arrayType:
			buf.WriteString(fmt.Sprintf(" []%s", p.Items.Type))
		default:
			buf.WriteString(fmt.Sprintf(" %s", p.Type))
		}
		buf.WriteString(fmt.Sprintf(" `json:%s`", strconv.Quote(n)))
	}
	buf.WriteString("\n}")
	return nil
}

func generateHandlers(paths openapi.Paths) error {
	var buf bytes.Buffer
	buf.WriteString(`package faultinfo
// Code generated by genserver.go. DO NOT EDIT.

import (
"net/http"
)
`)
	for _, pathitem := range paths {
		if err := generateHandler(&buf, pathitem.Get, pathitem.Parameters); err != nil {
			return err
		}
		if err := generateHandler(&buf, pathitem.Post, pathitem.Parameters); err != nil {
			return err
		}
		if err := generateHandler(&buf, pathitem.Put, pathitem.Parameters); err != nil {
			return err
		}
		if err := generateHandler(&buf, pathitem.Delete, pathitem.Parameters); err != nil {
			return err
		}
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return writeTo(src, "handlers_gen.go")
}

func generateHandler(buf *bytes.Buffer, op *openapi.Operation, pathParam []*openapi.Parameter) error {
	if op == nil {
		// skip if undefined path
		return nil
	}

	buf.WriteString(fmt.Sprintf("\n\nfunc %sHandler(w http.ResponseWriter, r *http.Request) {", op.OperationID))

	// request header
	generateParseHeader(buf, op.Security)
	parameters := append(pathParam, op.Parameters...)
	// request path variable
	for _, p := range parameters {
		if p.In == "path" {
			if p.Name == "" {
				return errors.New("path parameter name is empty")
			}
			if p.Name == "type" {
				return errors.New("cannot use `type` as path parameter name")
			}
			buf.WriteString(fmt.Sprintf("\n%s := mux.Vars(r)[%s]", camelCase(p.Name), strconv.Quote(p.Name)))
		}
	}

	// request body
	if op.RequestBody != nil {
		buf.WriteString("\nvar req " + strings.Split(op.RequestBody.Ref, "/")[3])
		buf.WriteString("\nif err := json.NewDecoder(r.Body).Decode(&req); err != nil {")
		buf.WriteString("\nw.WriteHeader(http.StatusBadRequest)")
		buf.WriteString("\nreturn")
		buf.WriteString("\n}")
	}

	isFirstArg := true
	buf.WriteString(fmt.Sprintf("\nout, err := logic.%s(", op.OperationID))
	for _, p := range parameters {
		if !isFirstArg {
			buf.WriteString(", ")
		}
		buf.WriteString(p.Name)
		isFirstArg = false
	}
	if op.RequestBody != nil {
		if !isFirstArg {
			buf.WriteString(", ")
		}
		buf.WriteString("req")
	}
	buf.WriteString(")")
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nw.WriteHeader(http.StatusInternalServerError)")
	buf.WriteString("\nreturn")
	buf.WriteString("\n}")
	buf.WriteString("\n}")

	return nil
}

func generateParseHeader(buf *bytes.Buffer, security *openapi.SecurityRequirement) {
	if security == nil || (*security)[0]["BearerAuth"] == nil {
		return
	}
	buf.WriteString(fmt.Sprintf("\nauthHeader := strings.Split(r.Header.Get(%s))", strconv.Quote("Authorization")))
	buf.WriteString(fmt.Sprintf("\nif len(authHeader) != 2 || authHeader[0] != %s {", strconv.Quote("Bearer")))
	buf.WriteString("\nw.WriteHeader(http.StatusUnauthorized)")
	buf.WriteString("\nreturn")
	buf.WriteString("\n}")
	buf.WriteString("\nbearerToken := authHeader[1]")
}

func camelCase(snakeCase string) string {
	var s []rune
	var afterUS bool
	for _, r := range snakeCase {
		if r == '_' {
			afterUS = true
			continue
		}
		if afterUS {
			r = unicode.ToUpper(r)
		}
		s = append(s, r)
		afterUS = false
	}
	return string(s)
}

func generateLogics(paths openapi.Paths) error {
	var buf bytes.Buffer
	buf.WriteString(`package faultinfo
// Code generated by genserver.go. DO NOT EDIT.
`)
	for _, pathitem := range paths {
		if err := generateLogic(&buf, pathitem.Get, pathitem.Parameters); err != nil {
			return err
		}
		if err := generateLogic(&buf, pathitem.Post, pathitem.Parameters); err != nil {
			return err
		}
		if err := generateLogic(&buf, pathitem.Put, pathitem.Parameters); err != nil {
			return err
		}
		if err := generateLogic(&buf, pathitem.Delete, pathitem.Parameters); err != nil {
			return err
		}
	}

	src, err := format.Source(buf.Bytes())
	//src = buf.Bytes()
	//err = nil
	if err != nil {
		return err
	}

	return writeTo(src, "logic_gen.go")
}

func generateLogic(buf *bytes.Buffer, op *openapi.Operation, pathParam []*openapi.Parameter) error {
	if op == nil {
		return nil
	}
	params := append(op.Parameters, pathParam...)
	buf.WriteString(fmt.Sprintf("\n\nfunc %s(", op.OperationID))
	for i, param := range params {
		if i != 0 {
			buf.WriteString(", ")
		}
		buf.WriteString(fmt.Sprintf("%s %s", camelCase(param.Name), param.Schema.Type))
	}
	buf.WriteString(")")

	okResp, ok := op.Responses["200"]
	if !ok {
		okResp, ok = op.Responses["201"]
		if !ok {
			return errors.New("no ok or created response")
		}
	}
	if okResp.Content != nil {
		buf.WriteString("(")
		schema := okResp.Content[applicationjson].Schema
		if schema.Ref != "" {
			ref := strings.Split(schema.Ref, "/")
			buf.WriteString(fmt.Sprintf("%s.%s", ref[2], ref[3]))
		} else {
			switch schema.Type {
			case arrayType:
				buf.WriteString("[]")
				if schema.Items.Type != "" {
					buf.WriteString(schema.Items.Type)
				} else {
					itemRef := strings.Split(schema.Items.Ref, "/")
					buf.WriteString(fmt.Sprintf("%s.%s", itemRef[2], itemRef[3]))
				}
			default:
				buf.WriteString(schema.Type)
			}
		}
		buf.WriteString(", error)")
	} else {
		buf.WriteString("error")
	}
	buf.WriteString(" {")
	buf.WriteString("\n}")
	return nil
}
