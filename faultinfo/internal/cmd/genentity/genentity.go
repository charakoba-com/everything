package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	flags "github.com/jessevdk/go-flags"
	strlib "github.com/nasa9084/go-strlib"
)

type options struct {
	TargetDir string `short:"d" long:"dir" required:"true"`
	SaveDir   string `short:"o" long:"save-dir" required:"true"`
}

type model struct {
	PackageName string
	Name        string
	Fields      []string

	TableName  string
	PrimaryKey string

	CanCreate bool
	CanFind   bool
	CanUpdate bool
	CanDelete bool
}

func main() { os.Exit(exec()) }

func exec() int {
	var opts options
	if _, err := flags.Parse(&opts); err != nil {
		return 1
	}
	models, err := parseDir(opts.TargetDir)
	if err != nil {
		fmt.Println(err)
		return 1
	}
	if err := generateRepositories(opts.TargetDir, opts.SaveDir, models); err != nil {
		fmt.Println(err)
		return 1
	}
	return 0
}

func parseDir(dir string) ([]model, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, skipper, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	if len(pkgs) == 0 {
		return nil, errors.New("no files to process")
	}
	if len(pkgs) > 1 {
		return nil, errors.New("too many packages to process")
	}
	var models []model
	for _, pkg := range pkgs {
		models, err = parsePackage(pkg)
		if err != nil {
			return nil, err
		}
	}
	return models, nil
}

func skipper(f os.FileInfo) bool {
	return !(strings.HasSuffix(f.Name(), "_test.go") || strings.HasSuffix(f.Name(), "_gen.go"))
}

func parsePackage(pkg *ast.Package) ([]model, error) {
	var models []model
	for _, file := range pkg.Files {
		var err error
		models, err = parseFile(file)
		if err != nil {
			return nil, err
		}
	}
	return models, nil
}

func parseFile(file *ast.File) ([]model, error) {
	var models []model
	for _, decl := range file.Decls {
		if gendecl, ok := decl.(*ast.GenDecl); ok {
			if gendecl.Tok != token.TYPE {
				continue
			}
			m, err := parseDecl(gendecl)
			if err != nil {
				return nil, err
			}
			if m != nil {
				m.PackageName = file.Name.Name
				models = append(models, *m)
			}
		}
	}
	return models, nil
}

func parseDecl(decl *ast.GenDecl) (*model, error) {
	var isModel bool
	var generateLine string
	for _, comment := range decl.Doc.List {
		generateLine = strings.TrimLeft(comment.Text, "// ")
		if strings.HasPrefix(generateLine, "+model") {
			isModel = true
			break
		}
	}
	if !isModel {
		return nil, nil
	}
	if len(decl.Specs) != 1 {
		return nil, errors.New("length of specs expected 1")
	}
	m, err := parseTypeSpec(decl.Specs[0])
	if err != nil {
		return nil, err
	}

	m.CanCreate = true
	m.CanFind = true
	m.CanUpdate = true
	m.CanDelete = true
	m.TableName = strlib.SnakeCase(m.Name)
	m.PrimaryKey = m.Fields[0]

	applyOption(m, generateLine)

	return m, nil
}

func parseTypeSpec(spec ast.Spec) (*model, error) {
	typeSpec, ok := spec.(*ast.TypeSpec)
	if !ok {
		return nil, errors.New("typespec is expected")
	}
	m := &model{Name: typeSpec.Name.Name}

	structType, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		return nil, nil
	}

	for _, af := range structType.Fields.List {
		m.Fields = append(m.Fields, af.Names[0].Name)
	}

	return m, nil
}

func applyOption(m *model, generateLine string) {
	for _, opt := range strings.Split(generateLine, " ") {
		switch opt {
		case "-create":
			m.CanCreate = false
		case "-find":
			m.CanFind = false
		case "-update":
			m.CanUpdate = false
		case "-delete":
			m.CanDelete = false
		}
		switch {
		case strings.HasPrefix(opt, "table="):
			m.TableName = strings.Split(opt, "=")[1]
		case strings.HasPrefix(opt, "pkey="):
			m.PrimaryKey = strings.Split(opt, "=")[1]
		}
	}
}

func generateRepositories(targetDir, saveDir string, models []model) error {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf(`package repository
// Code generated by genentity.go. DO NOT EDIT.

import (
"context"
"database/sql"

"github.com/charakoba-com/everything/faultinfo/%s"
"github.com/charakoba-com/everything/faultinfo/db"
)
`, filepath.Join(filepath.Dir(targetDir), models[0].PackageName)))

	for _, m := range models {
		if err := generateRepository(&buf, m); err != nil {
			return err
		}
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	f, err := os.OpenFile(filepath.Join(saveDir, "repository.go"), os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	f.Write(src)
	return nil
}

func generateRepository(buf *bytes.Buffer, m model) error {
	buf.WriteString(fmt.Sprintf("\n\ntype %sRepository struct {", m.Name))
	buf.WriteString("\nDB *sql.DB")
	buf.WriteString("\n}")

	buf.WriteString(fmt.Sprintf("\n\nfunc New%sRepository() (*%sRepository, error) {", m.Name, m.Name))
	buf.WriteString("\n_db, err := db.Get()")
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn nil, err")
	buf.WriteString("\n}")
	buf.WriteString(fmt.Sprintf("\nreturn &%sRepository{", m.Name))
	buf.WriteString("\nDB: _db,")
	buf.WriteString("\n}, nil")
	buf.WriteString("\n}")

	if m.CanCreate {
		generateCreateFunc(buf, m)
	}
	generateListupFunc(buf, m)
	if m.CanFind {
		generateFindFunc(buf, m)
	}
	if m.CanUpdate {
		generateUpdateFunc(buf, m)
	}
	if m.CanDelete {
		generateDeleteFunc(buf, m)
	}

	return nil
}

func generateCreateFunc(buf *bytes.Buffer, m model) {
	buf.WriteString(fmt.Sprintf("\n\nfunc (r *%sRepository) Create(ctx context.Context, v %s.%s) error {",
		m.Name, m.PackageName, m.Name))
	generateBeginTx(buf, false)
	buf.WriteString(fmt.Sprintf("\nstmt, err := tx.Prepare(%s)", strconv.Quote(generateCreateStatement(m))))
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn err")
	buf.WriteString("\n}")
	buf.WriteString("\nif _, err := stmt.Exec(")
	var fields []string
	for _, field := range m.Fields {
		fields = append(fields, fmt.Sprintf("v.%s", field))
	}
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString("); err != nil {")
	buf.WriteString("\nreturn err")
	buf.WriteString("\n}")
	buf.WriteString("\nreturn tx.Commit()")
	buf.WriteString("\n}")
}

func generateCreateStatement(m model) string {
	var buf bytes.Buffer
	buf.WriteString("INSERT INTO ")
	buf.WriteString(m.TableName)
	buf.WriteString(" (")
	var fields []string
	for _, f := range m.Fields {
		fields = append(fields, strlib.SnakeCase(f))
	}
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString(") VALUES(")
	var ph []string
	for i := 0; i < len(m.Fields); i++ {
		ph = append(ph, "?")
	}
	buf.WriteString(strings.Join(ph, ", "))
	buf.WriteString(")")

	return buf.String()
}

func generateFindFunc(buf *bytes.Buffer, m model) {
	buf.WriteString(fmt.Sprintf("\n\nfunc (r *%sRepository) FindByPK(ctx context.Context, pk interface{}) (*%s.%s, error) {", m.Name, m.PackageName, m.Name))
	generateBeginTx(buf, true)
	buf.WriteString(fmt.Sprintf("\nstmt, err := tx.Prepare(%s)", strconv.Quote(generateSelectStatement(m))))
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn nil, err")
	buf.WriteString("\n}")
	buf.WriteString("\nrow := stmt.QueryRow(pk)")
	buf.WriteString(fmt.Sprintf("\nvar v *%s.%s", m.PackageName, m.Name))
	var fields []string
	for _, field := range m.Fields {
		fields = append(fields, fmt.Sprintf("&v.%s", field))
	}
	buf.WriteString(fmt.Sprintf("\nif err := row.Scan(%s); err != nil {", strings.Join(fields, ", ")))
	buf.WriteString("\nreturn nil, err")
	buf.WriteString("\n}")
	buf.WriteString("\nreturn v, nil")
	buf.WriteString("\n}")
}

func generateSelectStatement(m model) string {
	var buf bytes.Buffer
	buf.WriteString("SELECT ")
	var fields []string
	for _, f := range m.Fields {
		fields = append(fields, strlib.SnakeCase(f))
	}
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(m.TableName)
	buf.WriteString(" WHERE ")
	buf.WriteString(strlib.SnakeCase(m.PrimaryKey))
	buf.WriteString(" = ?")
	return buf.String()
}

func generateUpdateFunc(buf *bytes.Buffer, m model) {
	buf.WriteString(fmt.Sprintf("\n\nfunc (r *%sRepository) Update(ctx context.Context, v %s.%s) error {", m.Name, m.PackageName, m.Name))
	generateBeginTx(buf, false)
	buf.WriteString(fmt.Sprintf("\nstmt, err := tx.Prepare(%s)", strconv.Quote(generateUpdateStatement(m))))
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn err")
	buf.WriteString("\n}")
	var fields []string
	for _, field := range m.Fields {
		fields = append(fields, fmt.Sprintf("v.%s", field))
	}
	buf.WriteString(fmt.Sprintf("\nif _, err := stmt.Exec(%s, v.%s); err != nil {", strings.Join(fields, ", "), m.PrimaryKey))
	buf.WriteString("\nreturn err")
	buf.WriteString("\n}")
	buf.WriteString("\nreturn tx.Commit()")
	buf.WriteString("\n}")
}

func generateUpdateStatement(m model) string {
	var buf bytes.Buffer
	buf.WriteString("UPDATE ")
	buf.WriteString(m.TableName)
	buf.WriteString(" SET (")
	var sets []string
	for _, field := range m.Fields {
		sets = append(sets, fmt.Sprintf("%s=?", strlib.SnakeCase(field)))
	}
	buf.WriteString(strings.Join(sets, ", "))
	buf.WriteString(") WHERE ")
	buf.WriteString(strlib.SnakeCase(m.PrimaryKey))
	buf.WriteString("=?")
	return buf.String()
}

func generateDeleteFunc(buf *bytes.Buffer, m model) {
	buf.WriteString(fmt.Sprintf("\n\nfunc (r *%sRepository) Delete(ctx context.Context, v %s.%s) error {", m.Name, m.PackageName, m.Name))
	generateBeginTx(buf, false)
	buf.WriteString(fmt.Sprintf("\nstmt, err := tx.Prepare(%s)", strconv.Quote(generateDeleteStatement(m))))
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn err")
	buf.WriteString("\n}")
	buf.WriteString(fmt.Sprintf("\nif _, err := stmt.Exec(v.%s); err != nil {", m.PrimaryKey))
	buf.WriteString("\nreturn err")
	buf.WriteString("\n}")
	buf.WriteString("\nreturn tx.Commit()")
	buf.WriteString("\n}")
}

func generateDeleteStatement(m model) string {
	var buf bytes.Buffer
	buf.WriteString("DELETE FROM ")
	buf.WriteString(m.TableName)
	buf.WriteString(" WHERE ")
	buf.WriteString(strlib.SnakeCase(m.PrimaryKey))
	buf.WriteString(" = ?")
	return buf.String()
}

func generateBeginTx(buf *bytes.Buffer, hasTwoRet bool) {
	buf.WriteString("\ntx, err := r.DB.BeginTx(ctx, nil)")
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn ")
	if hasTwoRet {
		buf.WriteString("nil, ")
	}
	buf.WriteString("err")
	buf.WriteString("\n}")
}

func generateListupFunc(buf *bytes.Buffer, m model) {
	buf.WriteString(fmt.Sprintf("\n\nfunc (r *%sRepository) Listup(ctx context.Context) ([]%s.%s, error) {", m.Name, m.PackageName, m.Name))
	generateBeginTx(buf, true)
	buf.WriteString(fmt.Sprintf("\nstmt, err := tx.Prepare(%s)", strconv.Quote(generateListupStatement(m))))
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn nil, err")
	buf.WriteString("\n}")
	buf.WriteString("\nrows, err := stmt.Query()")
	buf.WriteString("\nif err != nil {")
	buf.WriteString("\nreturn nil, err")
	buf.WriteString("\n}")
	buf.WriteString(fmt.Sprintf("\nvar vs []%s.%s", m.PackageName, m.Name))
	buf.WriteString("\nfor rows.Next() {")
	buf.WriteString(fmt.Sprintf("\nvar v %s.%s", m.PackageName, m.Name))
	buf.WriteString("\nif err := rows.Scan(")
	var fields []string
	for _, f := range m.Fields {
		fields = append(fields, fmt.Sprintf("&v.%s", f))
	}
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString("); err != nil {")
	buf.WriteString("\nreturn nil, err")
	buf.WriteString("\n}")
	buf.WriteString("\n}")
	buf.WriteString("\nreturn vs, nil")
	buf.WriteString("\n}")
}

func generateListupStatement(m model) string {
	var buf bytes.Buffer
	buf.WriteString("SELECT ")
	var fields []string
	for _, field := range m.Fields {
		fields = append(fields, strlib.SnakeCase(field))
	}
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(m.TableName)
	return buf.String()
}
